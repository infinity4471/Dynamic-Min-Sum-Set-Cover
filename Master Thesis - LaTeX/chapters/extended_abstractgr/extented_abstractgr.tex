\chapter{Εκτεταμένη Περίληψη στα Ελληνικά}

Στην παρούσα διπλωματική εργασία μελετάμε το πρόβλημα Multistage Min-Sum Set Cover, μια εκδοχή του γνωστού και μελετημένου προβλήματος Min-Sum Set Cover που μέχρι στιγμής δεν έχει εμφανιστεί στην βιβλιογραφία. Πρωτού περάσουμε στην παρουσιάση των αποτελεσμάτων μας είναι σημαντικό να κάνουμε μια αναδρομή στην ιστορία του προβλήματος και να δείξουμε τις βασικές τεχνικές που χρησιμοποιούνται στον σχεδιασμό προσεγγιστικών αλγορίθμων για κάθε διαφορετική παραλλαγή.

\section{Η Στατική Εκδοχή του Min-Sum Set Cover}

Στην παρούσα εκδοχή του προβλήματος μας δίνεται μια συλλογή από n σύνολα που συνολικά καλύπτουν m στοιχεία. Θέλουμε να βρούμε μια μετάθεση των m στοιχείων ώστε να ελαχιστοποιήσουμε το συνολικό κόστος κάλυψης των συνόλων. Το κόστος κάλυψης για κάθε σύνολο είναι η θέση του πρώτου στοιχείου του συνόλου στην μετάθεση που έχουμε επιλέξει. \\

Συγκεκριμένα, ορίζουμε το πρόβλημα Min Sum Set Cover ως εξής. Έστω το σύνολο στοιχείων $U$ με $|U|=n$, χωρίς βλάβη της γενικότητας θεωρούμε $U = \{1,2, ..., n \} = [ 1, n ]$. Επιπλέον, έστω m σύνολα $S_1, S_2, ..., S_m \subseteq U$. Ο σκοπός μας είναι να βρούμε μια μετάθεση των n στοιχείων που ελαχιστοποιούν το συνολικό κόστος των συνόλων $S_i$, δηλαδή το $\sum_{i=1}^m C( S_i )$ όπου το κόστος $C( S_i )$ κάθε συνόλου είναι η θέση του στοιχείου του συνόλου που εμφανίζεται πρώτο στην μετάθεση. \\

Το πρόβλημα Min Sum Set Cover έχει μελετηθεί εκτεταμμένα. Παρακάτω παρουσιάζουμε τον βασικό αλγόριθμο και τα αποτελέσματα όπως αυτά υπάρχουν στο \cite{FLT04}.

\subsection{Ο Άπληστος Αλγόριθμος}

Ο άπληστος αλγόριθμος για το Min Sum Set Cover είναι πολύ φυσιολογικός και απλός.

\begin{algorithm}[ht]
  \caption{Άπληστος Αλγόριθμος για το Min Sum Set Cover}\label{alg:mssc}
  \textbf{Είσοδος:} Ένα σύνολο $U$ καθώς και μια συλλογή m συνόλων $S_1, S_2, ..., S_m$\\
  \textbf{Έξοδος:} Μια μετάθεση των στοιχείων του $U$.

 \begin{algorithmic}[1]
    \STATE $\pi = \text{[ ]}$
    \WHILE { $\pi$ δεν περιέχει όλα τα στοιχεία του $U$}
        \STATE Βάλε στο τέλος του $\pi$ το στοιχείο του U που εμφανίζεται στα περισσότερα σύνολα.
    \ENDWHILE
    \RETURN $\pi$
  \end{algorithmic}
\end{algorithm}

\subsection{Βασικά Αποτελέσματα}

Παρόλο που ο αλγόριθμος είναι πολύ απλός στο \cite{FLT04} οι συγγραφείς δείχνουν τα ακόλουθα ισχυρά αποτελέσματα.

\begin{θεώρημα}\label{t:mssc_apx}
    Ο Αλγόριθμος \ref{alg:mssc} προσεγγίζει το min sum set cover με παράγοντα προσέγγισης το πολύ 4.
\end{θεώρημα}

Μιας και αυτός ο αλγόριθμος είναι απλός και φυσιολογικός ένα ερώτημα που δημιουργείται είναι το κατά πόσο κάποια πιο περίπλοκη τεχνική θα μπορούσε να δώσει αλγόριθμο με καλύτερο παράγοντα προσέγγισης από 4. Σε αυτό έρχεται να απαντήσει το ακόλουθο θεώρημα.

\begin{θεώρημα}\label{t:mssc_hardness}
    Για κάθε $\epsilon > 0$ είναι NP-Hard να προσεγγίσεις το min sum set cover με παράγοντα προσέγγισης $4-\epsilon$.
\end{θεώρημα}

\section{Η Γενικευμένη Εκδοχή του Min Sum Set Cover}

Μετά την παρουσιάση της στατικής εκδοχής του Min Sum Set Cover συνεχίζουμε με την γενίκευση του προβλήματος που ορίστηκε πρώτη φορά απ' τους Azar, Gamzu και Yin στο \cite{AGY09}. Σε αυτό το πρόβλημα μας δίνεται πάλι ένα σύνολο $U$ με $|U| = n$ και μια σcυλλογή συνόλων $S_1, S_2, ..., S_m$ καθώς και έναν αριθμό για κάθε σύνολο $K(S_i)$. Σκοπός μας είναι να υπολογίσουμε μια μετάθεση του συνόλου $U$ ώστε να ελαχιστοποιήσουμε το συνολικό κόστος κάλυψης όπως και στην απλή εκδοχή του προβλήματος $\sum_{i=1}^{m} C( S_i )$ όπου το κόστος κάλυψης $C(S_i)$ είναι η θέση του $K(S_i)$-οστού στοιχείου στην μετάθεση. \\

Στο \cite{AGY09} οι συγγραφείς παρουσιάζουν έναν Αλγόριθμο με παράγοντα προσέγγισης $O(logr)$ όπου $r = max_{i} \{ |S_i| \}$. Έπειτα, δόθηκε ένας αλγόριθμος με σταθερό παράγοντα προσέγγισης \cite{BGK10} βασισμένος σε γραμμικό προγραμματισμό. \\

Σε αυτή την ενότητα παρουσιάζουμε τα αποτελέσματα του \cite{SW11} όπου με την χρήση $\alpha$-point scheduling και κατάλληλη χρήση γραμμικού προγραμματισμού βελτιώνεται σημαντικά ο παράγοντας προσέγγισης του \cite{BGK10}. Η παρουσίαση των εν λόγω αποτελεσμάτων είναι σημαντική καθώς οι τεχνικές που χρησιμοποιήθηκαν στο \cite{SW11} χρησιμοποιούνται παραλλαγμένες για την εξαγωγή των δικών μας αποτελεσμάτων για το Multistage Min-Sum Set Cover. \\

Το πρώτο βήμα στον σχεδιασμό του αλγορίθμου για το πρόβλημα είναι η επίλυση του ακόλουθου Linear Programming Relaxation. Ορίζουμε τις μεταβλητές $y_{i,t}$ η οποία θέλουμε να είναι 1 αν και μόνο αν $C(S_i) < t$ (δηλαδή το $K(S_i)$-οστό στοιχείο του συνόλου $S_i$ εμφανίζεται πριν την θέση t) και επιπλέον τις μεταβλητές $x_{e,t}$ που θέλουμε να είναι 1 αν και μόνο αν το στοιχείο $e \in U$ βρίσκεται στην θέση $t$. Βάσει των παραπάνω προκύπτει το ακόλουθο γραμμικό πρόγραμμα.
\begin{equation*}
    \begin{array}{ll@{}ll}
        \text min & \displaystyle \sum_{t = 1}^n \sum_{i = 1}^{m} ( 1 - y_{i,t} ) &\\
        \text{ s.t } & \displaystyle \sum_{e \in U} x_{e,t} = 1~~~~\text{για κάθε }t \leq n &&\\
        & \displaystyle \sum_{t=1}^{n} x_{e,t} = 1~~~~\text{για κάθε }e \in U &&\\
        & \displaystyle \sum_{e \in S \setminus A} \sum_{t'<t} x_{e,t} \geq (K(S_i) - |A|) \cdot y_{i,t}~~~~\text{ για κάθε } i \leq m, A \subseteq S_i, t \leq n &&\\
        & \displaystyle x_{e,t}, y_{i,t} \in [ 0, 1 ] ~~~~\text{ για κάθε } e \in U, i \leq m, t \leq n
    \end{array}
\end{equation*}

Το γραμμικό πρόγραμμα φαίνεται εκ πρώτης όψης να έχει εκθετικά πολλά constraints, αφού δημιουργούμε ένα constraint για κάθε υποσύνολο του κάθε συνόλου $S_i$. Όπως μπορούμε να δούμε και στο \cite{BGK10} τα εκθετικά πολλα constraints μπορούν σε πολυωνυμικό χρόνο να διαχωριστούν ώστε να μπορούμε να υπολογίσουμε αποδοτικά την βέλτιστη λύση του γραμμικού προγράμματος. \\

Ο βασικός αλγόριθμος για την επίλυση του προβλήματος με παράγοντα προσέγγισης 28 βασίζεται στην μέθοδο $\alpha$ point scheduling. Συγκεκριμένα, για κάθε στοιχείο $e \in U$ επιλέγουμε ανεξάρτητα και ομοιόμορφα $\alpha_e \in [0,1]$. Έστω $t_{e,\alpha_e}$ η μικρότερη χρονική στιγμή $t'$ τ.ω $\sum_{t=1}^{t'} x_{e,t} \geq \alpha_e$. Σχηματίζουμε την τελική μετάθεση διατάζοντας τα στοιχεία $e \in U$ σε φθίνουσα σειρά ως προς τα $t_{e,\alpha_e}$ με αυθαίρετο tie-breaking. Για περισσότερες λεπτομέρειες ως προς την ανάλυση του αλγορίθμου παραπέμπουμε στο original paper \cite{BGK10}.

\section{Το πρόβλημα ανανέωσης λίστας(List Update)}

Πρωτού περάσουμε στην μελέτη της online εκδοχής του Min-Sum Set Cover παρουσιάζουμε ένα κλασικό online πρόβλημα το οποίο έχει μελετηθεί σε βάθος. Πέρα απ' το ότι το πρόβλημα List Update αποτελεί ένα απλό και εύπεπτο online πρόβλημα για εισαγωγή κινητοποίησε και σε μεγάλο βαθμό την γενίκευση του Min-Sum Set Cover ως προς την online και την offline-Multistage εκδοχή τους. \\

Το πρόβλημα List Update είναι ένα απ' τα κλασικά προβλήματα στον τομέα του Online Optimization. Μας δίνεται αρχικά μια μετάθεση του συνόλου $\{ 1,2, ...,n \}$ και ένα σύνολο από requests $r_1, r_2, ..., r_m$ όπου $r_i \in \{ 1,2,...,n \}$. Για κάθε request $r_i$ πληρώνουμε κάθε φορά του κόστος πρόσβασης που είναι η θέση του στοιχείου $r_i$ στην τωρινή μετάθεση. Έπειτα, έχουμε την επιλογή να μεταφέρουμε το συγκεκριμένο στοιχείο πιο κοντά στην αρχή της λίστας προκειμένου να κάνουμε τα μελλοντικά request 'φθηνότερα'.

Στην online εκδοχή του προβλήματος όταν μας δίνεται ένα συγκεκριμένο request δεν γνωρίζουμε τίποτα για τα μελλοντικά request που θα έρθουν.

\subsection{Ένας αφελής αλγόριθμος για το List Update}

Μια φυσιολογική πρώτη απόπειρα για να λύσουμε το πρόβλημα θα ήταν να διατάξουμε την λίστα βάσει της τωρινής συχνότητας πρόσβασης των στοιχείων. Διαισθητικά αυτός ο αλγόριθμος φαίνεται λογικός καθώς αν θέλουμε να κρατήσουμε χαμηλό το κόστος βγάζει αρκετό νόημα τα στοιχεία που ζητούνται συχνά να βρίσκονται στην αρχή της λίστας. Επιπλέον, το να διατάξουμε την μετάθεση με αυτόν τον τρόπο είναι εφικτό στο μοντέλο του προβλήματος (όπου κάθε φορά μπορούμε να κουνήσουμε μόνο το στοιχείο που ζητήθηκε) καθώς όταν μας έρχεται ένα request $r_i$, η συχνότητά του αυξάνεται και συνεπώς θα θέλουμε να το μεταφέρουμε πιο μπροστά στην λίστα. Δυστυχώς, το ακόλουθο λήμμα μας δείχνει ότι αυτός ο αλγόριθμος οδηγεί σε τετριμμένα κακό competitive ratio.

\begin{λήμμα}\label{l:frequency_bad}
    Ο αλγόριθμος \emph{Order By Frequency} είναι $\Omega( n )$-competitive.
\end{λήμμα}

\begin{proof}
    Ας υποθέσουμε ότι ξεκινάμε με την μετάθεση $[ 1,2,3,...,n ]$. Ας υποθέσουμε ότι μας έρχεται το ακόλουθο request sequence: Το στοιχείο 1 το ζητάμε n φορές, Το στοιχείο 2 το ζητάμε n φορές, ..., το στοιχείο $n$ το ζητάμε n φορές. Τώρα, αν θεωρήσουμε το κόστος πρόσβασης για το δεύτερο μισό των στοιχείων, δηλαδή τα στοιχεία $n/2, n/2 + 1, ..., n$. Καθένα απ' αυτά τα στοιχεία έχουν κόστος τουλάχιστον $n/2$ καθώς τα πρώτα $n/2$ στοιχεία έχουν κόστος n. Συνεπώς το συνολικό κόστος του αλγορίθμου γι' αυτό το παράδειγμα είναι $\Omega(n^3)$. \\
    
    Παρ' όλ' αυτάμ μπορούμε να δούμε ότι υπάρχει αλγόριθμος που πετυχαίνει συνολικό κόστος $O(n^2)$. Αν μετακινήσουμε κάθε φορά το ζητούμενο στοιχείο στην αρχή της λίστας βλέπουμε ότι το συνολικό κόστος είναι $O(n^2)$. Συνεπώς το competitive ratio του αλγορίθμου order by frequency algorithm είναι $\Omega(n)$.
\end{proof}

\subsection{Ο αλγόριθμος Move-To-Front}

Το παραπάνω λήμμα μας δίνει μια ωραία ιδέα για την κατασκευή ενός απλού και φυσιολογικού αλγορίθμου για το List Update. Μετακίνησε κάθε φορά το ζητούμενο στοιχείο στην αρχή της λίστας. Το εν λόγω αλγοριθμικό σχήμα που χρησιμοποιείται και στην offline εκδοχή του Min-Sum Set Cover καταφέρνει να πετύχει $O(1)$ competitiveness. Συγκεκριμένα, ο αλγόριθμος Move to Front(MTF) είναι 2-competitive για το List Update.

\begin{lemma}\label{l:mtf_competitive}
    Ο αλγόριθμος MTF είναι 2-Competitive για το List Update.
\end{lemma}

\subsection{Competitive Analysis για τον αλγόριθμο MTF}

Προκειμένου να αποδείξουμε το 2-competitiveness του αλγόριθμου MTF χρησιμοποιούμε την μέθοδο δυναμικού. Ορίζουμε συνάρτηση $\Phi: [0, m] \rightarrow \mathbb{Z}$ η οποία αποτυπώνει την κατάσταση της μετάθεσης μετά από κάθε request σε έναν ακέραιο αριθμό. Ο σκοπός μας είναι η συνάρτηση $\Phi( i )$ να εμπεριέχει πληροφορίες για την απόσταση της μετάθεσης που έχουμε δημιουργήσει απ' την βέλτιστη μετάθεση αφού εξυπηρετήσουμε το request $r_i$. \\

Έπειτα, ορίζουμε το amortized κόστος για κάθε βήμα βασιζόμενη στην συνάρτηση δυναμικού. Έστω $A(i) = MTF(i) + \Phi(i) - \Phi(i-1)$ όπου $MTF(i)$ είναι το κόστος που πληρώνει ο αλγόριθμος  Move-To-Front για να εξυπηρετήσει το i-οστό request. Παρατηρούμε ότι:

\begin{equation}\label{e:amortized_cost}
    \sum_{i=1}^m A(i) = \sum_{i=1}^m MTF(i) + \Phi(i) - \Phi(i-1) = \Phi(m) - \Phi(0) + \sum_{i=1}^m MTF(i)
\end{equation}

Συνεπώς, αν ορίζουμε την συνάρτηση δυναμικού με τέτοιο τρόπο ώστε $\Phi(m) - \Phi(0) > 0$ τότε το άθροισμα των amortized κοστών για όλα τα request που λαμβάνουμε είναι άνω φράγμα για το κόστος του αλγόριθμου MTF. \\

Πρωτού ορίσουμε την συνάρτηση δυναμικού, έστω $V(i)$ το σύνολο των ζευγών $(x,y)$ τ.ω το x στην μετάθεση που διατηρείται απ' τον αλγόριθμο MTF είναι αντιστραμμένο σε σχέση με το y  στην βέλτιστη μετάθεση αφού εξυπηρετηθεί το request i. Για να ξεκαθαρίσουμε τον ορισμό, έστω $Pos( \pi^i, x)$ η θέση του x στην μετάθεση $\pi^i$, δηλαδή $Pos(x) = (\pi^i)^{-1}(x)$. Έστω $o^i$ η βέλτιστη μετάθεση την χρονική στιγμή i, δηλαδή μια οποιαδήποτε μετάθεση που διατηρείται απ' τον βέλτιστο offline αλγόριθμο αφού εξυπηρετηθεί το request i. Ορίζουμε:

\begin{equation*}
    V(i) = \{ ( x,y ) \in [1, n] \times [1,n] \text{ s.t } Pos( \pi^i, x ) < Pos( \pi^i, y ) \land Pos( o^i, x ) > Pos( o^i, y )
\end{equation*}

Συνεπώς το $V(i)$ είναι το σύνολο των ζευγών (x,y) τ.ω το x να έρχεται πριν το y  στην μετάθεση που διατηρείται απ' τον αλγόριθμο MTF  αλλά το x  να έρχεται μετά το y  στην βέλτιστη μετάθεση. Τέλος, ορίζουμε $\Phi(i) = |V(i)|$ και είμαστε έτοιμοι να αποδείξουμε το ακόλουθο λήμμα.

\begin{λήμμα}\label{c:amortized_bound}
    Έστω $A(i)$ το amortized κόστος όπως ορίστηκε παραπάνω. Έστω $OPT(i)$ το κόστος της βέλτιστης λύσης αφού εξυπηρετήσουμε το i-οστό request, τότε $A(i) \leq 2 \cdot OPT(i)-1$.
\end{λήμμα}

\begin{proof}
    Έστω $r_i$ το i-οστό request. Έστω επιπλέον k το πλήθος των στοιχείων που εμφανίζονται πριν το  $r_i$ τόσο στην μετάθεση του MTF όσο και στην βέλτιστη μετάθεση και έστω l το πλήθος των στοιχείων που εμφανίζονται πριν το $r_i$ στην μετάθεση του MTF αλλά μετά το $r_i$ στην βέλτιστη μετάθεση. Σύμφωνα με αυτούς τους ορισμούς έχουμε $MTF(i) = l + k + 1$ και επιπλέον $OPT(i) \geq k + 1$. Τώρα, παρατηρούμε ότι αν μετακινήσουμε το $r_i$ στην αρχή της λίστας τότε δημιουργούμε k καινούργια inversions και καταστρέφουμε ακριβώς l inversions. Συνεπώς $\Phi(i) - \Phi(i-1) \leq k - l$. Συνδυάζοντας τις παραπάνω σχέσεις λαμβάνουμε:
    
    \begin{equation*}
        A(i) = MTF(i) + \Phi(i) - \Phi(i-1) \leq l + k + 1 + ( k - l ) = 2 \cdot k + 1 \leq 2 \cdot ( OPT(i) - 1 ) \leq 2 \cdot OPT(i) - 1
    \end{equation*}
    
    \noindent και η απόδειξη έχει ολοκληρωθεί.
\end{proof}

Τώρα είμαστε έτοιμοι να αποδείξουμε ότι ο αλγόριθμος MTF είναι 2-Competitive. Συνδυάζοντας τα παραπάνω λήμματα λαμβάνουμε $MTF = \sum_{i=1}^m MTF(i) \leq 2*OPT - m + \Phi(0) - \Phi(m) \leq 2*OPT - m + \binom{n}{2}$. Η τελευταία ανισότητα προκύπτει απ' το ότι $\Phi(0) = 0$ και $\Phi(i) \leq \binom{n}{2}$ αφού το πλήθος των αντιστροφών είναι πάντα μικρότερο ή ίσο από $\binom{n}{2}$.

\subsection{Κάτω φράγμα στο Competitive Ratio}

Στην παράγραφο αυτή αποδεικνύουμε ότι κάθε online αλγόριθμος για το πρόβλημα List Update είναι τουλάχιστον 2-competitive.

\begin{proof}
    Για κάθε online αλγόριθμο κατασκευάζουμε ένα adversarial παράδειγμα εισόδου ως εξής: Θέτουμε $r_i$ ίσο με το τελευταίο στοιχείο της τωρινής μετάθεσης. Προφανώς, για μια μετάθεση μεγέθους n και m συνολικά request το κόστος κάθε online αλγόριθμου είναι $n \cdot m$. Θα δείξουμε ωστόσο ότι υπάρχει ακολουθία από μεταθέσεις της οποίας το συνολικό κόστος είναι το πολύ $\frac{nm}{2}$. \\
    
    Έστω μια ακολουθία από τυχαίες μεταθέσεις. Το αναμενόμενο κόστος για να εξυπηρετήσουμε το κάθε request $r_i$ είναι $\frac{n}{2}$ και συνεπώς το συνολικό αναμενόμενο κόστος του αλγόριθμου είναι $\frac{nm}{2}$. Μπορούμε εύκολα να δούμε λοιπόν ότι θα πρέπει να υπάρχει ακολουθία μεταθέσεων με κόστος το πολύ ίσο με το αναμενόμενο και συνεπώς η απόδειξη έχει ολοκληρωθεί.
\end{proof}

\section{Η online έκδοση του Min Sum Set Cover}

Πρωτού περάσουμε στον βασικό κορμό της παρούσας εργασίας παρουσιάζουμε την τελευταία σχετική παραλλαγή του προβλήματος που κινητοποίησε και την μελέτη του offline Multistage προβλήματος στο οποίο δουλέψαμε. Στα online προβλήματα, έχουμε μια κατάσταση η οποία εξελίσσεται στον χρόνο και οφείλουμε να απαντάμε ερωτήματα χωρίς να γνωρίζουμε εκ των προτέρων τι ερωτήματα θα μας έρθουν στο μέλλον (βλ. List Update). '

Στο \cite{FKKSV20} οι συγγραφείς εξερευνούν την Online εκδοχή του Min-Sum Set Cover. Παρατηρούν ότι παρόλο που το Online Min-Sum Set Cover αποτελεί γενίκευση του List Update(Στην ουσία το List Update είναι μια ειδική περίπτωση του Online Min-Sum Set Cover όπου όλα τα request έχουν μέγεθος 1, δηλάδη $|S_t| = 1$) ο αλγόριθμος Move-to-Front που αποτελεί τον κλασικό αλγόριθμο που πετυχαίνει το βέλτιστο competitive ratio για το List Update δεν δίνει ενδιαφέροντα αποτελέσματα. Στην συνέχεια αυτού του κεφαλαίου θεωρούμε πως τα request είναι $r$-ομοιόμορφα, δηλαδή $|S_t| = r \text{ για κάθε } t \in [T]$.

\subsection{Ένας αλγόριθμος χωρίς μνήμη για το Online-Dynamic Min-Sum Set Cover}

Το πρώτο αποτέλεσμα που παρουσιάζουμε απ' το αντίστοιχο paper είναι ένας αλγόριθμος χωρίς μνήμη για την δυναμική εκδοχή Online Min-Sum Set Cover. Ένας online αλγόριθμος λέγεται 'χωρίς μνήμη' ανν οι αποφάσεις που λαμβάνονται την χρονική στιγμή $t$ δεν εξαρτώνται απ' τις προηγούμενες χρονικές στιγμές. Παρακάτω, παρουσιάζουμε τον αλγόριθμο Move-All-Equally(MAE). Επί της ουσίας αυτό που κάνουμε είναι πως όταν μας δωθεί κάποιο request $S_t$ μετακινούμε κάθε στοιχείο του $S_t$ στην τωρινή μετάθεση $\pi^{t-1}$ προς τα αριστερά μέχρι να φτάσουν στην αρχή της μετάθεσης. Αναλυτικά ο αλγόριθμος φαίνεται παρακάτω.

\begin{algorithm}[ht]
  \caption{Move-All-Equally}
  \textbf{Input:} The given request at time t $S_t$ and the permutation $\pi^{t-1}$.\\
  \textbf{Output:} A permutation at time $t$ $\pi^t$.

 \begin{algorithmic}[1]
    \STATE $k_t \leftarrow min\{ i | \pi^{t-1} [ i ] \in S_t \}$
    \STATE decrease the index of all elements on $S_t$ by $k_t - 1$.

  \end{algorithmic}
\end{algorithm}

Ο παραπάνω αλγόριθμος αν και έχει ενδιαφέρουσες ιδιότητες φαίνεται να παρουσιάζει ένα gap μεταξύ άνω και κάτω ορίου ως προς το competitive ratio.

\begin{lemma}
    Το Competitive ratio του αλγορίθμου Move-All-Equally είναι $\Omega( r^2 )$.
\end{lemma}

\begin{proof}
    Κατασκευάζουμε μια adversarial (κακόβουλη) ακολουθία εισόδου για να δείξουμε το κάτω όριο. Κάθε φορά φτιάχνουμε ένα request $S_t$ που αποτελείται απ' τα τελευταία r στοιχεία της τωρινής μετάθεσης. Εφ' όσον ο αλγόριθμος μετακινεί τα στοιχεία με την ίδια ταχύτητα παρατηρούμε πως έχουμε $n/r$ requests οπου μεταξύ τους δεν θα έχουν κοινά στοιχεία. Συνεπώς, για να καλύψουμε κάθε request βέλτιστα έχουμε κόστος $\Theta(n/r)$ ενώ ο αλγόριθμος MAE καταφέρνει να πετύχει κόστος $\Omega(n \cdot r)$. Συνεπώς, από σύγκριση των δύο λαμβάνουμε το κάτω όριο για το competitive ratio.
\end{proof}

Αν και η ανάλυση του αλγορίθμου δεν μας δίνει κάποιο matching άνω όριο έχουμε το παρακάτω ενδιαφέρον αποτέλεσμα. Για περισσότερες λεπτομέρειες στην ανάλυση του αλγορίθμου ο αναγνώστης μπορεί να ανατρέξει στο \cite{FKKSV20}.

\begin{lemma}
    Το Competitive Ratio του αλγορίθμου Move-All-Equally είναι το πολύ $O( 2^{\sqrt( logn \cdot logr ) } ).$
\end{lemma}

\subsection{Ο Αλγόριθμος Lazy Rounding}

Σε αυτή την ενότητα παρουσιάζουμε ένα κάτω φράγμα για κάθε ντετερμινιστικό αλγόριθμο για το Online Min-Sum Set Cover και επιπλέον παρουσιάζουμε τον αλγόριθμο Lazy Rounding που αποτελεί έναν ντετερμινιστικό αλγόριθμο που ταιριάζει σε competitive ratio στο εν λόγω κάτω φράγμα (πλην κάποιες σταθερές).

\begin{theorem}
    Κάθε ντετερμινιστικός αλγόριθμος για το Online Min-Sum Set Cover έχει competitive ratio τουλάχιστον $(r+1)(1 - \frac{1}{n+1})$.
\end{theorem}

Για την απόδειξη του θεωρήματος οι συγγραφείς χρησιμοποιούν ένα πιθανοτικό επιχείρημα μέσου όρου πολύ παρόμοιο με αυτό που παρουσιάσαμε για το κάτω φράγμα στο List-Update \cite{ST85}. Σε κάθε βήμα ο adversary κατασκευάζει ένα request πάλι με τα τελευταία $r$ στοιχεία της μετάθεσης και συνεπώς έχει access cost τουλάχιστον $(n-r+1)$. Με ένα απλό συνδυαστικό επιχείρημα δείχνουν ότι για κάθε request set $S_t$ μεγέθους $r$ και κάθε $i \in [n-r+1]$, το πλήθος των μεταθέσεων $\pi$ με κόστος πρόσβασης $\pi(S_t)=i$ είναι $\binom{n-i}{r-1} \cdot r! \cdot (n-r)!$. Αθροίζοντας πάνω σε όλες τις μεταθέσεις και διαιρώντας με $n!$ για να πάρουμε το μέσο κόστος πρόσβασης λαμβάνουμε ότι η βέλτιστη ακολουθία έχει κόστος πρόσβαση το πολύ $\frac{n+1}{r+1}$ και συνεπώς το κόστος πρόσβασης είναι τουλάχιστον $(r+1)(1 - \frac{1}{n+1})$. Για περισσότερες λεπτομέρειες ο αναγνώστης μπορεί να ανατρέξει στο paper \cite{FKKSV20}. \\

\noindent
Παρακάτω παρουσιάζουμε σε high-level τον αλγόριθμο Lazy Rounding. \\

\begin{enumerate}
    \item Εφαρμόζουμε τον αλγόριθμο Multiplicative Weights Update (MWU) σαν black-box με learning rate $1/n^3$. Χρησιμοποιώντας βασικά αποτελέσματα από learning theory οι συγγραφείς δείχνουν ότι: $AccessCost(MWU) \leq \frac{5}{4} AccessCost(OPT)$.
    
    \item Με την χρήση ενός online σχήματος rounding μετατρέπουμε κάθε τυχαιοκρατικό αλγόριθμο A σε ντετερμινιστικό, που συμβολίζουμε ως $Derand(A)$, με κόστος πρόσβασης το πολύ $2r \cdot \mathbb{R}[AccessCost(A)]$, χωρίς όμως καμία εγγύηση ως προς το κόστος μετακίνησης του $Derand(A)$.
    
    \item Ο αλγόριθμος Lazy-Rounding είναι επί της ουσίας μια lazy εκδοχή του $Derand(MWU)$ (εφαρμόζουμε δηλαδή του online σχήμα rounding στον αλγόριθμο Multiplicative Weights Update Algorithm) που ανανεώνει την μετάθεση αν και μόνο αν η κατανομή του MWU έχει αλλάξει κατά πολύ. Ας ορίσουμε ένα χρονικό παράθυρο όπου ο αλγόριθμος Lazy-Rounding δεν αλλάζει την μετάθεση φάση. Οι συγγραφείς παρατηρούν ότι σε κάθε φάση:
        \begin{itemize}
            \item $AccessCost(Lazy-Rounding) \leq 4r \cdot \mathbb{E}[AccessCost(MWU)]$.
            \item $MovingCost(Lazy-Rounding) \leq \mathbb{E}[AccessCost(MWU)]$.
        \end{itemize}
\end{enumerate}

Συνδυάζοντας τις παραπάνω ιδιότητες λαμβάνουμε: $$Cost(Lazy-Rounding) \leq (4r+1) \mathbb{E}[AccessCost(MWU)] \leq (5r+2) Cost(OPT)$$.

\begin{theorem}
    Ο ντετερμινιστικός αλγόριθμος Lazy-Rounding είναι (5r+2) competitive για την Online εκδοχή του Min-Sum Set Cover.
\end{theorem}

\section{Multistage Min-Sum Set Cover}

\noindent
Στις προηγούμενες ενότητες κάναμε μια ιστορική αναδρομή και καλύψαμε τις βασικές θεωρητικές έννοιες που απαιτούνται για την κατανόηση του προβλήματος. Το αντικείμενο της παρούσας εργασίας αποτελεί η δυναμική offline εκδοχή του Min-Sum Set Cover. Κατά την διάρκεια της υπόλοιπης εργασίας όσο παρουσιάζουμε τα βασικά μας αποτελέσματα αναφερόμαστε στο εν λόγω πρόβλημα ως Multistage Min-Sum Set Cover, Dynamic Min-Sum Set Cover ή $\DSSC$. 

\subsection{Βασικές Έννοιες και Ορισμοί}

Συμβολίζουμε με $U$ το σύνολο όλων των στοιχείων $e$, έχουμε φυσικά ότι $|U| = n$. Συμβολίζουμε με $\pi$ μια οποιαδήποτε μετάθεση των στοιχείων του $U$ και ως $\pi_i$ συμβολίζουμε το στοιχείο που βρίσκεται στην θέση $i$. Επιπλέον, συμβολίζουμε με $\mathrm{Pos}( e, \pi )$ την θέση του στοιχείου $e \in U$ στην μετάθεση $\pi$.

\begin{ορισμός}[Απόσταση Kendall-Tau]\label{d:KT}
Δεδομένων δύο μεταθέσεων $\pi^A, \pi^B$ θεωρούμε πως ένα ζεύγος στοιχείων $(e,e')$ είναι αντεστραμμένο αν και μόνο αν $\mathrm{Pos}(e,\pi^A) > \mathrm{Pos}(e',\pi^A)$ και $\mathrm{Pos}(e,\pi^B) < \mathrm{Pos}(e',\pi^B)$ ή αντίστροφα. Η απόσταση Kendall-Tau δύο μεταθέσεων $\pi^A, \pi^B$ είναι το πλήθος των αντεστραμμένων ζευγών στοιχείων και συμβολίζεται ως $\dkt( \pi^A, \pi^B )$.
\end{ορισμός}

\begin{ορισμός}[Spearman' Footrule Distance]\label{d:FR}
Η FootRule distance δύο μεταθέσεων $\pi^A,\pi^B$ ορίζεται ως $\mathrm{d}_{\mathrm{FR}}(\pi^A,\pi^B) = \sum_{e \in U}|\mathrm{Pos}(e,\pi^A) - \mathrm{Pos}(e,\pi^B)|$.
\end{ορισμός}
\noindent Παρατηρούμε πως η απόσταση Kendall-Tau και η FootRule distance είναι κατά προσέγγιση ισοδύναμες. Συγκεκριμένα, $\dkt(\pi^A,\pi^B) \leq \mathrm{d}_{\mathrm{FR}}(\pi^A,\pi^B) \leq 2 \cdot \dkt(\pi^A,\pi^B)$. Επιπλέον ικανοποιούν την τριγωνική ανισότητα.
\begin{ορισμός} Ένας πίνακας $n \times n$ με θετικά στοιχεία (όπου οι γραμμές αντιπροσωπεύουν τα στοιχεία και οι στήλες τις θέσεις) ονομάζεται στοχαστικός αν και μόνο αν $\sum_{i = 1}^n A_{ei} = 1$ για κάθε $e\in U$ και διπλά στοχαστικός αν επιπλέον έχουμε $\sum_{e \in U} A_{ei}=1$ for all $1\leq i \leq n$.
\end{ορισμός}

Η έννοια της απόστασης FootRule μπορεί να επεκταθεί και σε στοχαστικούς πίνακες. Δεδομένων δύο διπλα στοχαστικών πινάκων $A,B$ θεωρούμε το πρόβλημα της μεταφοράς ελάχιστου κόστους, όπου θέλουμε να μετατρέψουμε την γραμμή $A_e$ στην γραμμή $B_e$ όπου η μεταφορά μιας μονάδας μάζας από την στήλη $i$ στην στήλη $j$ έχει κόστος $|i-j|$.

\begin{ορισμός}\label{d:distance_lp}
Η απόσταση FootRule μεταξύ δύο στοχαστικών πινάκων $A,B$ την οποία συμβολίζουμε ως $\mathrm{d}_{\mathrm{FR}}(A,B)$, είναι η βέλτιστη τιμή του παρακάτω γραμμικού προγράμματος,
\begin{equation*}
    \begin{array}{ll@{}ll}
        \text min & \displaystyle \sum_{e \in U} \sum_{i = 1}^{n} \sum_{j=1}^n |i - j| \cdot f_{ij}^e &\\
        \text{ s.t } & \displaystyle \sum_{i=1}^{n} f_{ij}^e = B_{ej}~~~~\text{για κάθε }e \in U \text{ kai }j=1,\ldots ,n&&\\
        & \displaystyle \sum_{j=1}^{n} f_{ij}^e = A_{ei}~~~~\text{για κάθε }e \in U \text{ και }i=1,\ldots, n&&\\
        & \displaystyle f_{ij}^e \geq 0~~~~~~~~~~~\text{για κάθε } e \in U \text{ και }i,j = 1,\ldots, n
    \end{array}
\end{equation*}
\end{ορισμός}

Πλέον είμαστε σε θέση να ορίσουμε το πρόβλημα της Δυναμικής Κάλυψης Συνόλου Ελάχιστου Αθροίσματος αυστηρά.

\begin{ορισμός}[\textbf{Multistage Min-Sum Set Cover}]
Δεδομένου ενός συνόλου $U$, μιας ακολουθίας από requests $R_1,\ldots,R_T \subseteq U$ και μιας αρχικής μετάθεσης των συνόλων του $U$, $\pi^0$ ο στόχος μας είναι να επιλέξουμε μια ακολουθία από μεταθέσεις $\pi^1,\ldots,\pi^T$ οι οποία ελαχιστοποιεί την ακόλουθη ποσότητα,
$$\sum_{t=1}^{T} \pi^t(R_t) + \sum_{t=1}^{T} \dkt ( \pi^t, \pi^{t-1} )$$
όπου $\pi^t(R_t)$ είναι η θέση του πρώτου στοιχείου του συνόλου $R_t$ που συναντάμε στην μετάθεση $\pi^t$, $\pi^t(R_t) = \min \{1\leq i \leq n:~ \pi_i^t \in R_t\}$.
\end{ορισμός}
\noindent Στην συνέχεια, θα αναφερόμαστε στην ποσότητα $\sum_{t=1}^T\pi^t(R_t)$ ως \textbf{κόστος κάλυψης}  και στην ποσότητα $\sum_{t=1}^T \dkt(\pi^t,\pi^{t-1})$ ως \textbf{κόστος μετακίνησης}.
Συμβολίζουμε με $\pi_{\mathrm{Opt}}^t$ την μετάθεση της βέλτιστης λύσης για το $\DSSC$ την χρονική στιγμή $t$, με $o_t$ το στοιχείο που η βέλτιστη λύση χρησιμοποιεί για να καλύψει το request $R_t$ (δηλαδή το στοιχείο του $R_t$ που εμφανίζεται πρώτο στην μετάθεση $\pi_{\mathrm{Opt}}^t$), και με $\mathrm{OPT}_{\DSSC}$ το κόστος της βέλτιστης λύσης. Τέλος, θα λέμε πως ένα instance του $\DSSC$ είναι \textit{r-φραγμένο} στην περίπτωση που η πληθικότητα όλων των request είναι φραγμένη από $r$, $|R_t| \leq r$.

\subsection{Αποτελέσματα περί δυσκολίας του Dynamic Min-Sum Set Cover}\label{s:main}
\noindent Πρωτού περάσουμε στην παρουσίαση των βασικών αλγορίθμων και των αποτελεσμάτων μας παρουσιάζουμε ένα βασικό θεώρημα με το οποίο αποδεικνύεται πως το $\DSSC$ είναι τουλάχιστον όσο δύσκολο και το πρόβλημα της κάλυψης συνόλου. Συγκεκριμένα, υπάρχει μια αναγωγή που είναι
approximation-preserving απ' το $\mathrm{Set-Cover}$ στο  
$\DSSC$ που μας δίνει τα ακόλουθα αποτελέσματα μη-προσεγγισιμότητας.

\begin{θεώρημα}\label{t:hardness}
\begin{itemize}
    \item Δεν υπάρχει αλγόριθμος πολυωνυμικού χρόνου με παράγοντα προσέγγισης $o(logn)$ για το $\DSSC$ εκτός και αν $\mathrm{P = NP}$.
    
    \item Για $r$-φραγμένες ακολουθίες, δεν υπάρχει αλγόριθμος πολυωνυμικού χρόνου με παράγοντα προσέγγισης $o(r)$ για το $\DSSC$, εκτός και αν υπάρχει αλγόριθμος με παράγοντα προσέγγισης
    $o(r)$ για το $\mathrm{Set-Cover}$ όπου κάθε στοιχείο καλύπτεται απ' το πολύ $r$ σύνολα.
\end{itemize}
\end{θεώρημα}

\noindent Η απόδειξη του παραπάνω θεωρήματος είναι σχετικά απλή, δεδομένου ενός instance του $\mathrm{Set-Cover}$ κατασκευάζουμε ένα instance για το $\DSSC$ όπου η αρχική μετάθεση $\pi^0$ εμπεριέχει στις πρώτες θέσεις dummy στοιχεία (δηλαδή στοιχεία που δεν εμφανίζονται σε κανένα request) και στις τελευταίες θέσεις τα σύνολα του $\mathrm{Set-Cover}$ (θεωρούμε ένα στοιχείο του $\DSSC$ για κάθε σύνολο του $\mathrm{Set-Cover}$). Η απόδειξη αναλυτικά παρουσιάζεται στο αγγλικό κείμενο της εν λόγω διπλωματικής εργασίας.

\section{Αλγόριθμοι Προσέγγισης για το Dynamic Min-Sum Set Cover}

Στην συνέχεια παρουσιάζουμε 2 προσεγγιστικούς αλγορίθμους που αποτελούν και τον βασικό κορμό αυτής της εργασίας. Ο πρώτος εξ' αυτών αποτελεί έναν πολυωνυμικό τυχαιοκρατικό αλγόριθμο με παράγοντα προσέγγισης $O(\log^2 n)$ για την γενική εκδοχή του προβλήματος, ενώ ο δεύτερος έχει παράγοντα προσέγγισης $O(r^2 )$  για r-φραγμένες ακολουθίες από requests. \\

Και οι δύο αλγόριθμοι βασίζονται σε τεχνικές rounding ενός γραμμικού προγράμματος που ονομάζουμε \textit{Fractional Move To Front} το οποίο αποτελεί LP Relaxation του \textit{Move To Front}, ένα πρόβλημα στενά συνδεδεμένο με το $\DSSC$. Για περισσότερες πληροφορίες ο αναγνώστης μπορεί να ανατρέξει στις ενότητες του αγγλικού κειμένου όπου καλύπτονται οι έννοιες του γραμμικού προγραμματισμού καθώς και του List Update. \\

Στο πρόβλημα Move-to-Front(για συντομία $~\mathrm{MTF}$) ψάχνουμε να βρούμε μια ακολουθία από μεταθέσεις $\pi^1,\ldots,\pi^T$ τέτοια ώστε σε κάθε 'γύρο' $t$, επιλέγουμε ένα στοιχείο του συνόλου $R_t$ το οποίο τοποθετούμε στην αρχή της μετάθεσης $\pi^t$. Σκοπός μας είναι να ελαχιστοποιήσουμε το άθροισμα $\sum_{t=1}^T \mathrm{d}_{\mathrm{FR}}(\pi^t,\pi^{t-1})$.

\begin{ορισμός}\label{d:frac_MTF}

Δεδομένης μιας ακολουθίας από request $R_1,\ldots,R_T \subseteq U$ και μια αρχική μετάθεση $\pi^0$, θεωρούμε το ακόλουθο γραμμικό πρόγραμμα που ονομάζουμε  $\mathrm{Fractional- MTF}$,

\begin{equation*}
    \begin{array}{ll@{}ll}
        \text min & \displaystyle \sum_{t=1}^{T} \mathrm{d}_{\mathrm{FR}}(A^t,A^{t-1})&\\
        \text{ s.t } & \displaystyle \sum_{i=1}^{n} A_{ei}^t = 1 ~~~~\text{για κάθε }e \in U\text{ και } t = 1,\ldots, T &&\\
        & \displaystyle \sum_{e \in U} A_{ei}^t = 1 ~~~~\text{για κάθε }i = 1,\ldots,n\text{ και } t = 1,\ldots, T&\\
        & \displaystyle \sum_{e \in R_t} A_{e1}^t = 1 ~~~\text{για κάθε } t = 1,\ldots, T&\\
        & \displaystyle A^0 = \pi^0 &&\\
        & \displaystyle A_{ei}^t \geq 0 ~~~~~~~~\text{για κάθε } e \in U, ~i = 1,\ldots, n\text{ και } t = 1,\ldots, T&\\
    \end{array}
\end{equation*}

όπου $\mathrm{d}_{\mathrm{FR}}(\cdot,\cdot)$ είναι το Footrule distance.

\end{ορισμός}
\noindent Υπάρχει ένα κομψό επιχείρημα (που έχει εμφανιστεί προηγουμένως και σε άλλες εργασίες π.χ, \cite{FKKSV20}) που δείχνει πως η βέλτιστη λύση του $\mathrm{MTF}$ είναι το πολύ $4 \cdot \mathrm{OPT}_{\DSSC}$. Στο παρακάτω λήμμα παρουσιάζουμε το επιχείρημα πως το $\mathrm{Fractional- MoveToFront}$ είναι ενα relaxation του $\DSSC$ με παράγοντα προσέγγισης 4.
\begin{λήμμα}\label{l:relax}

$\sum_{t=1}^T \mathrm{d}_{\mathrm{FR}}(A^t,A^{t-1}) \leq 4 \cdot \mathrm{OPT}_{\DSSC}$
όπου $A^1,\ldots,A^t$ is the optimal solution of $\mathrm{Fractional- MTF}$.
\end{λήμμα}

\subsection{Τυχαιοκρατικός Αλγόριθμος με Παράγοντα Προσέγγισης $O(log^2n)$}

Όπως έχουμε ήδη αναφέρει, οι βασικές συνεισφορές αυτής της εργασίας είναι ο σχεδιασμός ορισμένων \textit{rounding schemes} όπου μετασχηματίζουν την βέλτιστη λύση, $A^1,\ldots,A^T$, του γραμμικού προγράμματος $\mathrm{Fractional- MTF}$ σε μια ακολουθία από μεταθέσεις $\pi^1,\ldots,\pi^T$. Αυτό γίνεται ώστε να μπορέσουμε να φράξουμε το κόστος μετακίνησης των αλγορίθμων μας από το κόστος μετακίνησης $\sum_{t=1}^T \dfr(A^t,A^{t-1})$. Έπειτα, μπορούμε ξεχωριστά να φράξουμε το κόστος κάλυψης, $\sum_{t=1}^T \pi^t(R_t)$ δείχνοντας πως πάντα ένα στοιχείο του $R_t$ βρίσκεται στις πρώτες θέσεις της μετάθεσης $\pi^t$. \\

Η βασική τεχνική δυσκολία στον σχεδιασμό των εν λόγω rounding schemes είναι πως πρέπει να πιστοποιήσουμε και να αποδείξουμε ότι το κόστος μετακίνησης των λύσεών μας $\sum_{t=1}^T\dkt(\pi^t,\pi^{t-1})$ φράζεται κατά προσέγγιση από το κόστος μετακίνησης $\sum_{t=1}^T\dfr(A^t,A^{t-1})$. Παρόλο που η σύνδεση μεταξύ διπλά στοχαστικών πινάκων και μεταθέσεων έχει μελετηθεί πολύ και υπάρχουν διάφορα rounding schemes όπου μετατρέπουν διπλά στοχαστικούς πίνακες σε κατανομές πιθανότητας πάνω σε μεταθέσεις (όπως το Birkhoff–von Neumann decomposition η τα σχήματα των \cite{BGK10,SW11,BBFT20,FKKSV20}), η χρήση τέτοιων αλγοριθμικών σχημάτων ως μάυρα κουτιά δεν φαίνεται να δίνει κάποιο θετικό αποτέλεσμα για το $\DSSC$. Για παράδειγμα στην περίπτωση όπου $A^1 = \dots = A^T$ και συνεπώς $\sum_{t=1}^T \dfr(A^t,A^{t-1}) = \dfr(A^1,A^0)$. Σε περίπτωση όπου ένας τυχαιοκρατικός αλγόριθμος εφαρμοστεί ανεξάρτητα σε κάθε $A^t$, υπάρχει πάντα η πιθανότητα να έχουμε $\pi^t \neq \pi^{t-1}$ και συνεπώς το κόστος μετακίνησης θα αποκλείνει απεριόριστα απ' το $\dfr(A^1,A^0)$ καθώς μεγαλώνει το $T$. Αυτό μας οδηγεί στο να χρησιμοποιήσουμε κάποιου είδους coupling όπου μετατρέπει την ακολουθία των πινάκων $A^1,\ldots,A^T$ σε ακολουθία μεταθέσεων $\pi^1,\ldots,\pi^T$. Ο πρώτος αλγόριθμος που παρουσιάζουμε στην συνέχεια χρησιμοποιεί μια τέτοια μέθοδο και αποτελεί και την βασική συνεισφορά της εργασίας μας για request με αυθαίρετο πλήθος στοιχείων.

\begin{algorithm}[ht]
  \caption{Τυχαριοκρατικός Αλγόριθμος για το πρόβλημα $\DSSC$}\label{alg:rand_rounding}
  \textbf{Input:} Μια ακολουθία από request $R_1,\ldots,R_T$ και μια αρχική μετάθεση των στοιχείων $\pi^0$.\\
  \textbf{Output:} Μια ακολουθία μεταθέσεων $\pi^1,\ldots,\pi^T$.

 \begin{algorithmic}[1]
 \STATE Find the optimal solution $A^0=\pi^0,A^1,\ldots,A^T$ for $\mathrm{Fractional-MTF}$. 

     \FOR {each element $e \in U$}
        \STATE Select $\alpha_e$ uniformly at random in $[0,1]$.
        \ENDFOR

 \FOR {$t=1 \ldots T$ }
              
     \FOR {all elements $e \in U$}
                \STATE $I_e^t := \mathrm{argmin}_{1\leq i \leq n} \{ \log n \cdot \sum_{s=1}^i 
                A_{es}^t \geq \alpha_e\}$.
        \ENDFOR
            
            \STATE $\pi^t:=$ sort elements according to $I_e^t$ with ties being broken lexicographically.
\ENDFOR
  \end{algorithmic}
\end{algorithm}

Το rounding scheme του παραπάνω αλγορίθμου, θέτει το coupling που αναφέραμε μεταξύ διαφορετικών χρονικών στιγμών με το να απαιτεί κάθε στοιχείο $e$ να διαλέξει ένα $\alpha_e$ μια φορά στην αρχή και για όλη την διάρκεια του αλγορίθμου καθώς και με την επιλογή να σπάει τις ισοπαλίες με αλφαβητική σειρά (οποιοσδήποτε συνεπής κανόνας για τις ισοπαλίες θα δούλευε εξίσου καλά).  \\

Μπορούμε να δείξουμε ότι ανεξάρτητα απ την ακολουθία των διπλά στοχαστικών πινάκων που λαμβάνουμε ως είσοδο ο αλγόριθμος μας παράγει μια ακολουθία μεταθέσεων με αναμενόμενο συνολικό κόστος μετακίνησης το πολύ $4\log^2 n$ φορές το κόστος μετακίνησης της ακολουθίας πινάκων και συνεπώς το συνολικό κόστος μετακίνησης του αλγορίθμου φράζεται από $4\log^2 n \cdot \mathrm{OPT}_{\DSSC}$. 

\begin{θεώρημα}\label{t:rand}
Ο παραπάνω αλγόριθμος έχει λόγο προσέγγισης $O(\log^2 n)$ για το πρόβλημα $\DSSC$.
\end{θεώρημα}

\noindent Παρότι στο βήμα~$7$ του αλγορίθμου πολλαπλασιάζουμε τα στοιχεία του πίνακα $A^t$ με $\log n$ ο λόγος προσέγγισης είναι  $O(\log^2 n)$. Εκ πρώτης όψης αυτό φαίνεται περίεργο αλλά η εξήγηση προκύπτει πολύ φυσιολογικά. Για τις περισσότερες θέσεις $i$, η πιθανότητα ότι ένα στοιχείο $e$ θα έχει εν τέλει index $I_e^t = i$ είναι περίπου $\log n \cdot A_{ei}^t$, αλλά επειδή κάθε index $j \leq i$ κατά μέση τιμή επιλέγεται από άλλα $\log n$ στοιχεία, η αναμενόμενη θέση του στοιχείου $e$ στην τελική μετάθεση θα είναι περίπου $ \log^2 n$ φορές η μέση τιμή του
$\mathrm{argmin}_{1\leq i \leq n} \{ \sum_{s=1}^i A_{es}^t \geq \alpha_e\}$. Αυτό το φαινόμενο έρχεται σε αντιστοιχία με το επιχείρημα στην εργασία \cite{FLT04} όπου αποδεικνύεται για την στατική εκδοχή του προβλήματος ότι ο άπληστος αλγόριθμος έχει παράγοντα προσέγγισης 4 για το πρόβλημα \textit{Min-Sum Set Cover}

\subsection{Ντετερμινιστικος Αλγόριθμος για r-φραγμένες Ακολουθίες}

Συνεχίζουμε με τον δεύτερο αλγόριθμο που αφορά r-φραγμένες ακολουθίες από request. Γνωρίζουμε ότι στο πρόβλημα $\mathrm{Set-Cover}$ υπάρχουν διάφορα αλγοριθμικά σχήματα βασισμένα σε γραμμικό προγραμματισμό που πετυχαίνουν παράγοντα προσέγγισης $r$, όπου κάθε στοιχείο μπορεί να ανήκει το πολύ σε $r$ σύνολα. Θέλουμε να δούμε επομένως κατά πόσο μπορούμε να κάνουμε κάτι καλύτερο για το $\DSSC$ από $O(\log^2 n)$ στην περίπτωση που έχουμε $r$-φραγμένη ακολουθία από request. \\

Ο απλός άπληστος αλγόριθμος που παρουσιάζουμε παρακάτω μας δίνει παράγοντα προσέγγισης $O(r^2)$ σε αυτή την περίπτωση.

\begin{algorithm}[H]
  \caption{Ένας άπληστος αλγόριθμος για το $\DSSC$ για $r$-φραγμένες ακολουθίες.}\label{alg:greedy_rounding}
  \textbf{Είσοδος:} Μια ακολουθία από request $R_1,\ldots,R_T$ with $|R_t| \leq r$ και μια αρχική μετάθεση $\pi^0$.\\
  \textbf{Output:} Μια ακολουθία μεταθέσεων $\pi^1,\ldots,\pi^T$.

 \begin{algorithmic}[1]
 \STATE Find the optimal solution $A^0=\pi^0,A^1,\ldots,A^T$ for $\mathrm{Fractional-MTF}$. 

 
 \FOR {$t=1 \ldots T$ }
              
        \STATE $\pi^t:=$ in $\pi^{t-1}$, move to the first position an element $e \in R_t$
        such that $A_{e1}^t \geq 1/r$
\ENDFOR
  \end{algorithmic}
\end{algorithm}

\noindent Ο παράγοντας προσέγγισης $O(r^2)$ αποδεικνύεται πλήρως στην συνέχεια της διπλωματικής εργασίας στο θεώρημα~\ref{t:greedy}. Η βασική τεχνική δυσκολία είναι πως δεν μπορούμε να συγκρίνουμε απευθείας το κόσοτος του αλγορίθμου μας με τον στόχο $\sum_{t=1}^T \dfr(A^t,A^{t-1})$ και συνεπώς εφαρμόζουμε μια άλλη τεχνική. \\

Στο πρώτο βήμα (λήμμα~\ref{l:upper_bound_r}), αποδεικνύουμε την ύπαρξη μιας ακολουθίας από διπλά στοχαστικούς πίνακες $\hat{A}^0 =\pi^0,\hat{A}^1,\ldots,\hat{A}^T$ όπου ο καθένας εκ των οποίων  $\hat{A}^t$ ικανοποιεί τα ακόλουθα κριτήρια,

\begin{enumerate}
    \item Τα στοιχεία του είναι \textbf{πολλαπλάσια του $1/r$}
    \item $\hat{A}^t_{e_t 1} \geq 1/r$ όπου $e_t$ είναι το στοιχείο που ο αλγόριθμος μεταφέρει στην πρώτη θέση την χρονική στιγμή $t$.
    \item Η ακολουθία $\hat{A}^0 =\pi^0,\hat{A}^1,\ldots,\hat{A}^T$ έχει κόστος το πολύ $\sum_{t=1}^T \mathrm{d}_{\mathrm{FR}}(A^t,A^{t-1})$.
\end{enumerate}

Προκειμένου να δείξουμε πως μια τέτοια ακολουθία υπάρχει κατασκευάζουμε ένα κατάλληλο γραμμικό πρόγραμμα (βλέπε ορισμό~\ref{def:lp_2}) βασισμένοι στα στοιχεία όπου ο αλγοριθμός μας μεταφέρει στην πρώτη θέση και αποδεικνύουμε πως έχει βέλτιστη λύση όπου όλες οι μεταβλητές παίρνουν τιμές που είναι πολλαπλάσια του $1/r$. Προκειμένου να το κάνουμε αυτό, συσχετίζουμε το γραμμικό πρόγραμμα του ορισμού~\ref{def:lp_2} με μια κλασματική εκδοχή του προβλήματος $k$-$\mathrm{Paging}$ \cite{BBN12} και βασισμένοι στην βέλτιστη πολιτική εκδίωξης στοιχείων 
(\textit{Διώξε το στοιχείο που εμφανίζεται αργότερα ξανά στο μέλλον}). Σχεδιάζουμε λοιπόν έναν αλγόριθμο που παράγει βέλτιστες λύσεις για το γραμμικό πρόγραμμα με τιμές πολλαπλάσια του $1/r$. \\

Στο δεύτερο βήμα (λήμμα~\ref{l:r_integral}), δείχνουμε ότι για κάθε ακολουθία πινάκων $\hat{A}^0 =\pi^0,\hat{A}^1,\ldots,\hat{A}^T$ που ικανοποιούν τις ιδιότητες που αναφέραμε παραπάνω, το συνολικό κόστος κίνησης του άπληστου αλγορίθμου είναι το πολύ $O(r^2) \cdot \sum_{t=1}^T \dfr(\hat{A}^t,\hat{A}^{t-1})$. Αυτό το δείχνουμε με την χρήση κατάλληλης συνάρτησης δυναμικού βασισμένη σε μια γενίκευση της απόστασης Kendall-Tau (βλέπε ορισμό~\ref{d:frac_KT}).

\begin{θεώρημα}\label{t:greedy}
Ο άπληστος αλγόριθμος για $r$-φραγμένες ακολουθίες request έχει παράγοντα προσέγγισης $O(r^2)$ για το $\DSSC$.
\end{θεώρημα}